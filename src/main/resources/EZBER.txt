Moduller

keywords
- exportS
- exports to xx
- requireS
- requireS transitive
- openS
- open module myModule
- uses
- provides x with y

- module-info boş(0 byte) olabilir! Derlenir.


jmod params
- create
- extract
- describe
- list
- hash

-d
-p  "--module-path"
-m  "--module"

jar için;
c create jar
v verbose output(Jar toolunun yaptığı işleri, jar içine konan dosyaları listele.)
f jar file name(burada klasör belirtirsek klasör hali hazırda olmalıdır.)
C (-C out .) out klasörü içindeki bütün dosyaları sıkıştır.

java --list-modules komutu JDK içindeki modülleri listeler.
java --show-module-resolution -p x -m b/c

jar -f mods/zoo.animal.feeding.jar -d
jar --file mods/zoo.animal.feeding.jar --describe-module

jdeps -s mods/zoo.animal.feeding.jar
jdeps -summary mods/zoo.animal.feeding.jar
jdeps --jdk-internals myApp.jar   internal package tavsiyeleri
jdeps ‐jdkinternals myApp.jar


java.all yok, jdk.base yok!

java.base
java.naming
java.compiler
java.net.http 	
java.sql
java.datatransfer 	
java.prefs 	
java.sql.rowset
java.desktop 	
java.rmi 	
java.transaction.xa
java.instrument 	
java.scripting 	
java.xml
java.logging 	
java.se 	
java.xml.crypto
java.management
java.management.rmi 	

jdk.compiler
jdk.net
jdk.accessiblity
jdk.jconsole
jdk.jdeps
jdk.naming.rmi
jdk.charsets
jdk.jdi
jdk.jshell
jdk.httpserver
jdk.localdata
jdk.xml.dom
jdk.jartool
jdk.management
jdk.zipfs
jdk.javadoc
jdk.management.jfr 		


JDBC;
Komut satırında Driver jarı şu şekilde belirtilir;
    java -cp "<path_to_derby>/derby.jar" TestConnect.java
Connection string de zorunlu olanlar;
      jdbc:dbVendor:vendorString
ps.setInt(1,"w") de sadece int olarak parametre sırası belirtir! Diğer rs.getInt("w") deki string alan metod ile karıştırma.
ps.executeQuery(sql) buradaki sql string’i normal statement olarak algılanır ve bind parametreleri yerine konmaz!
All JDBC code throws a SQLException and must be handled!!!
ResultSet içindeki kolonlar 1 den başlar!

Excepitons;
Unchecked Excepiton: Runtime ve Error
Checked Exception: Diğerleri

Unchecked örnekler;
NullPointerException 
ArithmeticException 	
ArrayIndexOutOfBoundsException
ClassCastException
IllegalArgumentException	
IllegalStateException
NumberFormatException

Checked Excepitons;
FileNotFoundException	
IOException
ParseException
SQLException

FileNotFoundException extends IOException extends Exception
NumberFormatException is a subclass of IllegalArgumentException

Exception sınıfları toString() metodu sınıf ismini ve hata mesajını yazdırırlar! toString() == java.io.FileNotFoundException: Hata mesajı(varsa) 

Return ederken catch bloğu finally bloğuna değişkeni/objeyi gönderir. Eğer gönderilen primitive ise finally bloğu bu değeri değiştiremez, nesne ise değiştirebilir. Son dönen finally olduğu için onun değeri kalır. 

Catch de birden fazla exception yakalanması durumunda Bu hatalarda aralarında kalıtım olan sınıflar yazılamaz, derlenmez. 

Base hata fırlatıyorsa, child hata fırlatmamayı seçebilir. Yani child sadece daraltabilir. Child base de ki exception'ı daha da genişletemez! yoksa kod derlenmez. 


Localization;
Language zorunlu, en
Contry optional,  US			en_US

DecimalFormat da 0, yoksa yerine sıfır koy, # ise yoksa yerine hiçbirşey koyma demek.


# SECURITY

4 serialization metodu;

private void writeObject(ObjectOutputStream s) throws Exception {
      ObjectOutputStream.PutField fields = s.putFields();
      fields.put("name", name);
      fields.put("ssn", encrypt(ssn));
      s.writeFields();
   }
   private void readObject(ObjectInputStream s) throws Exception {
      ObjectInputStream.GetField fields = s.readFields();
      this.name = (String)fields.get("name", null);
      this.ssn = decrypt((String)fields.get("ssn", null));
   }   
   
public synchronized Object readResolve() throws ObjectStreamException {
public Object writeReplace() throws ObjectStreamException {


Serialize olacak alanları belirlemek;
private static final ObjectStreamField[] serialPersistentFields = { new ObjectStreamField("name", String.class) };
Bu alan private static final olmalıdır.


Collections;
Wrappers
Short.valueOf((short) 1)  s.shortValue
Short.parseShort("1")

A set is a collection that does not allow duplicate entries.
A queue is a collection that orders its elements in a specific order for processing. A typical queue processes its elements in a first-in, first-out order, but other orderings are possible.
A HashSet stores its elements in a hash table, which means the keys are a hash and the values are an Object.
A TreeSet stores its elements in a sorted tree structure, it is always sorted
LinkedList earlier in the List section. In addition to being a list, it is a double-ended queue
The data structures that involve sorting do not allow null values.
A map is a collection that maps keys to values, with no duplicate keys allowed.

add metodu Collection dan ötürü eklemeyemezse hata fırlatmaz, sadece false döner. Queue interface hariç. 


Queue<Integer> queue = new LinkedList<>();

boolean add(E e) 	 Adds an element to the back of the queue and returns true or throws an exception	Yes
E element() 	     Returns next element or throws an exception if empty queue	Yes
boolean offer(E e) 	 Adds an element to the back of the queue and returns whether successful	No
E remove() 	         Removes and returns next element or throws an exception if empty queue	Yes
E poll() 	         Removes and returns next element or returns null if empty queue	No
E peek() 	         Returns next element or returns null if empty queue	No
(next element en baştakini temsil ediyor!)
pop()				 En baştaki elemanı siler


Map metodları;
void clear()                                Removes all keys and values from the map.
boolean containsKey(Object key) 	        Returns whether key is in map.
boolean containsValue(Object value) 	    Returns whether value is in map.
boolean contains     --- Bu metod list de var, map de yok!!
Set<Map.Entry<K,V>> entrySet() 	            Returns a Set of key/value pairs.
void forEach(BiConsumer(K key, V value)) 	Loop through each key/value pair.

V get(Object key) 	                        Returns the value mapped by key or null if none is mapped.
V getOrDefault(Object key, V defaultValue) 	Returns the value mapped by the key or the default value if none is mapped.

boolean isEmpty() 	                        Returns whether the map is empty.
Set<K> keySet() 	                        Returns set of all keys.

V merge(K key, V value, Function(<V, V, V> func)) 	Sets value if key not set. Runs the function if the key is set to determine the new value. Removes if null.

Merge method;
Has a null value in map	    ---   N/A (mapping function not called)	  ---   Update key's value in map with value parameter.
Has a non-null value in map	---   null 	                              ---   Remove key from map.
Has a non-null value in map	---   A non-null value	                  ---   Set key to mapping function result.
Is not in map	            ---   N/A (mapping function not called)   ---   Add key with value parameter to map directly without calling mapping function.

V put(K key, V value) 	         Adds or replaces key/value pair. Returns previous value or null.
V putIfAbsent(K key, V value) 	 Adds value if key not present and returns null. Otherwise, returns existing value. if value is null, updates the value
V remove(Object key) 	                    Removes and returns value mapped to key. Returns null if none.
V replace(K key, V value) 	                Replaces the value for a given key if the key is set. Returns the original value or null if none.
void replaceAll(BiFunction<K, V, V> func) 	Replaces each value with the results of the function.
int size() 	                                Returns the number of entries (key/value pairs) in the map.
Collection<V> values() 	                    Returns Collection of all values.


Remember that numbers sort before letters, and uppercase letters sort before lowercase letters.


Difference	
java.lang  Comparable 	compareTo()   1 param     lambda NOK
java.util  Comparator   compare()     2 param     lambda OK

![](media/comparator_helpers.PNG)

List<?> q = List.of("mouse", "parrot");    // Q TİPİ oBJECT TİR! 	

Sınıflarda;
class Parcel2<T>{
	<X> Parcel2(X x) {
		// Constructor
	}	
}

class Parcel3<T>{
	<X> void deliver(X x) {
		System.out.println(x.getClass());
	}
}

Metodlarda ise;
public static <T> void sink(T t) { }
public static <T> T identity(T t) { return t; }